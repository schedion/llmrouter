"""Load model catalog generated by GitHub Actions."""

from __future__ import annotations

import json
import logging
import os
from dataclasses import dataclass
from typing import Dict, Iterable, List, Mapping, Optional

import httpx

logger = logging.getLogger(__name__)

MODEL_INDEX_ENV = "LLMROUTER_MODEL_INDEX_URL"
DEFAULT_MODEL_INDEX_URL = "https://raw.githubusercontent.com/schedion/llmrouter/refs/heads/main/generated/model_index.json"
LOCAL_MODEL_INDEX = "config/model_index.json"

PROVIDER_API_KEYS: Dict[str, str] = {
    "groq": "PROVIDER_KEY_GROQ",
    "openrouter": "PROVIDER_KEY_OPENROUTER",
    "nvidia_nim": "PROVIDER_KEY_NVIDIA_NIM",
    "huggingface": "PROVIDER_KEY_HUGGINGFACE",
}

# Backward-compatibility alias for scripts that previously imported API_KEY_ENV
API_KEY_ENV = PROVIDER_API_KEYS


class AutoConfigError(RuntimeError):
    """Raised when the pre-generated model catalog cannot be loaded."""


@dataclass(frozen=True)
class ProviderTemplate:
    model: str
    api_key_env: str
    name_suffix: str
    base_url: Optional[str]
    extra_headers: Mapping[str, str]
    allow_paid: bool = False
    priority_offset: int = 0
    circuit_breaker: Optional[Mapping[str, int]] = None
    mock_failure_rate: float = 0.0


@dataclass(frozen=True)
class CanonicalModel:
    canonical: str
    aliases: List[str]
    providers: Dict[str, ProviderTemplate]


def _default_index_urls() -> List[str]:
    env_url = os.environ.get(MODEL_INDEX_ENV)
    urls = []
    if env_url:
        urls.append(env_url)
    urls.append(DEFAULT_MODEL_INDEX_URL)
    return urls


def _load_remote_json(url: str) -> Optional[dict]:
    try:
        with httpx.Client(timeout=10.0) as client:
            response = client.get(url)
            response.raise_for_status()
            return response.json()
    except Exception as exc:  # pragma: no cover - network access
        logger.warning("Failed to download model index from %s: %s", url, exc)
        return None


def _load_local_json(path: str) -> Optional[dict]:
    if not os.path.exists(path):
        return None
    try:
        with open(path, "r", encoding="utf-8") as handle:
            return json.load(handle)
    except Exception as exc:
        logger.warning("Failed to load local model index %s: %s", path, exc)
        return None


def load_model_index() -> dict:
    for url in _default_index_urls():
        data = _load_remote_json(url)
        if data:
            return data
    data = _load_local_json(LOCAL_MODEL_INDEX)
    if data:
        return data
    raise AutoConfigError("Unable to load model index from remote or local sources")


def discover_provider_templates(required_providers: Iterable[str]) -> Dict[str, CanonicalModel]:
    index = load_model_index()
    providers_required = [provider.lower() for provider in required_providers]

    models = {}
    for entry in index.get("models", []):
        canonical = entry.get("canonical")
        if not canonical:
            continue
        entry_providers = entry.get("providers", {})
        if not all(provider in entry_providers for provider in providers_required):
            continue
        provider_templates: Dict[str, ProviderTemplate] = {}
        for provider, payload in entry_providers.items():
            template = ProviderTemplate(
                model=payload.get("model"),
                api_key_env=payload.get("api_key_env") or PROVIDER_API_KEYS.get(provider, ""),
                name_suffix=canonical,
                base_url=payload.get("base_url"),
                extra_headers=payload.get("extra_headers", {}) or {},
                allow_paid=payload.get("allow_paid", False),
                priority_offset=payload.get("priority_offset", 0),
                circuit_breaker=payload.get("circuit_breaker") or {},
                mock_failure_rate=payload.get("mock_failure_rate", 0.0),
            )
            provider_templates[provider] = template
        models[canonical] = CanonicalModel(
            canonical=canonical,
            aliases=sorted({canonical, *entry.get("aliases", [])}),
            providers=provider_templates,
        )

    return models


def discover_common_models(required_providers: Iterable[str]) -> List[str]:
    return sorted(discover_provider_templates(required_providers).keys())
